# 1. 스케줄링의 목적
`스케줄링이란 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말한다.`  
스케줄링의 주된 목적은 멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하는 것이다.  
- 공평성: 모든 프로세스가 공평하게 실해되어야 한다. 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링해야 한다.
- 효율성: 자원을 효율적으로 사용해 `자원이 사용되지 않는 시간이 없도록` 스케줄링해야 한다.
- 안정성: 우선순위를 고려해 `높은 우선순위의 프로세스를 먼저 처리`하도록 스케줄링해야 한다.
- 반응 시간 보장: 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에 `일정 시간 내에 응답할 수 있도록` 스케줄링해야 한다.
- 무한 연기 방지: 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링해야 한다.

# 2. 스케줄링의 단계
## 2.1 프로세스를 스케줄링 하기 위한 큐
- `Ready Queue`: 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- `Device Queue`: I/O device의 처리를 기다리는 프로세스의 집합

## 2.2 CPU 스케줄러
<img width="500" alt="스케줄러" src="https://github.com/fbgjung/backend-springboot-study/assets/104186871/5d3a575d-27d6-4a3e-8e80-3298dd1e6a8e">


- 장기 스케줄링  
    - 프로세스를 활성화 할지 말지 결정하는 것
    - Ready Queue 에 어떤 프로세스를 넣을지 결정해 `메모리에 올라가는 프로세스 수를 조절`한다.
    - 잡 스케줄링, 승인 스케줄링
    - 현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않는다.
    - 시분할 방식에는 장기스케줄러가 없다. -> 모든 작업이 무조건 Ready 상태이다.
    - 프로세스의 상태 변화 : New -> Ready(in memory)
    
- 중기 스케줄링
    - 프로세스가 활성화 된 후를 담당
    - `메모리에 로드된 프로세스 수를 동적으로 조절`한다.
    - 프로세스 상태 변화 : Ready -> Suspended
    - 프로세스에서 메모리를 빼앗는 문제를 다루는 스케줄러이다.
    - `스왑아웃` : 메모리 부족시 현재 메모리에 있는 프로세스 중 일부를 보조 저장 장치(하드 디스크 등)로 옮겨 메모리를 확보한다. 스왑아웃된 프로세스는 Suspended 상태가 된다. 
    - `스왑인` : 필요할 때 저장 장치에서 메모리로 다시 프로세스를 옮겨와 실행한다. 
    - `스와핑` : 스왑아웃과 스왑인처럼 프로세스를 통채로 메모리 영역과 저장 공간으로 옮기는 것을 스와핑이라고 한다. 스와핑하면 메모리 공간보다 많은 프로세스를 실행할 수 있다.

- 단기 스케줄링
    - Ready Queue에 있는 대기 상태의 프로세스 중 `어떤 프로세스를 다음으로 실행(Running)할지 스케줄링 알고리즘으로 결정`한다.
    - 프로세스에 CPU를 할당(scheduler dispatch)하는 문제를 다루는 스케줄러
    - 처리속도가 ms 단위로 매우 빠르다.
    - CPU 스케줄링
    - 디스패치 : 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것
    - 프로세스의 상태 변화 : Ready -> Running -> Waiting -> Ready

# 3. 스케줄링 알고리즘
CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용한다.  

### 스케줄링 알고리즘 평가 기준
- `CPU 사용률`: CPU를 놀리지 않고 사용하는지 판단
- `처리량`: 단위 시간당 실행한 프로세스 수
- `응답 시간`: 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
- `반환 시간`: 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
- `대기 시간`: 프로세스가 대기 큐에서 대기하는 시간의 총합

## 3.1 비선점형 스케줄링
실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미한다.  
- `FCFS 스케줄링`: 준비 큐에 `먼저 들어온 프로세스가 우선순위`를 갖는 알고리즘이다. 준비 큐에 먼저 들어온 프로세스를 먼저 실행한다.
- `SJF 스케줄링` (SJN): `실행 시간이 짧은 프로세스가 우선순위`를 갖는 알고리즘이다. 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행시간이 가장 짧은 프로세스부터 실행한다. 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있다.  

> 기아 상태(starvation): 프로세스마다 우선순위가 있는데, 우선순위가 높은 프로세스만 수행되어 우선순위가 낮은 특정 프로세스는 계속 실행되지 못하는 것을 의미한다.  


## 3.2 선점형 스케줄링
스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미한다.  
- `RR 스케줄링`: 프로세스 간 우선순위가 없다. 모든 프로세스를 순서대로 일정 시간 동안 실행하며, 일정 시간을 초과하면 다른 프로세스를 실행한다. 
    - 일정 시간: 시간 단위를 의미하며 타임 퀀텀 또는 타임 슬라이스라고도 한다.
    - 일반적으로 시간 단위는 10~100미리초다.
    - 콘텍스트 스위칭이 빈번하게 일어나서 오버헤드가 크다는 단점이 있지만, 모든 프로세스가 반복 수행되어 응답 속도가 빠르다는 장점도 있다.
- `SRTF 스케줄링`: 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행하는 알고리즘이다. 
    - 한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행 시간이 더 짧은 프로세스가 CPU를 차지하게 된다.
    - 평균 대기 시간이 짧다는 장점이 있지만, 수행 시간이 긴 프로세스는 기아 상태가 되기 싶다.
- `멀티 레벨 스케줄링`: 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘이다. 
    - 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용할 수 있다.
    - 여러 개의 큐는 foreground 큐와 background 큐로 나뉜다.
    - foreground 큐에는 응답 속도가 중요한 프로세스가 들어가고
    - background 큐에는 응답 속도보다 성능을 중요시하는 프로세스가 들어간다.

# Q
SJF 스케줄링에서 무조건 프로세스1을 실행하고 나서 실행시간이 짧은 프로세스 우선순위가 적용이 되는가?

## 참고
[[O/S] CPU Scheduler와 Dispatcher](https://velog.io/@ss-won/OS-CPU-Scheduler%EC%99%80-Dispatcher)