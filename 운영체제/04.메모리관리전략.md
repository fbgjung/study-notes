다수의 프로세스를 실행하려면 한정된 메모리 공간에 많은 프로세스를 로드할 수 있어야 한다.  
그래서 메모리 공간을 더 효율적으로 활용하기 위한 여러 방안이 고안되었다.  
연속 메모리 할당, 페이징, 세그먼테이션 등의 작동 방식과 장단점을 이해해보자.

# 1. 논리 메모리와 물리 메모리
CPU가 프로세스를 처리할 때 보는 주소 값과 실제 메모리의 주소 값은 다르다.  

## 1.1 논리 메모리 영역(가상 메모리 영역)
프로세스가 보는 메모리 영역이다.  
CPU가 프로세스를 실행하며 보는 주소 값을 논리 주소 또는 가상 주소하고 한다.

## 1.2 물리 메모리 영역
실제로 사용되는 메모리 영역(RAM)이다.  
실제 메모리에서 사용되는 주소를 물리 주소라고 한다.  

## 1.3 메모리 관리 장치(MMU, Memory Management Unit)
<img width="500" alt="MMU" src="https://github.com/fbgjung/studyAlgorithm/assets/104186871/90e93f18-b398-41c5-a8a7-c4224e93c7f1">

CPU가 프로세스를 실행할 때 사용하는 주소 값과 실제 주소 값이 다르므로 `논리 주소를 물리 주소로 변환`해줘야 하는데 이러한 동작을 하는 하드웨어 장치를 메모리 관리 장치라고 한다.  
CPU에 위치하며, CPU에서 메모리에 접근하기 전에 MMU를 거쳐 논리 주소에 해당하는 물리 주소를 얻는다.  
MMU는 보호해야 하는 메모리 영역에 대한 접근을 제한해 메모리를 보호하는 역할을 한다.  

# 2. 연속 메모리 할당
멀티 프로세스 환경에서 `여러 프로세스를 메모리에 연속적으로 로드하는 방법`

## 2.1 고정 분할 방식
메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식이다.  
분할된 영역의 크기는 서로 다를 수 있으며, 분할된 크기는 고정된다.  
메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점이 있다.  
단편화(fragmentation) 문제가 발생할 수 있다.  
### 단편화(fragmentation)
프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 단편화이다. 

### `외부단편화`
남아있는 메모리의 크기가 실행하고자 하는 프로세스보다 크지만, 연속적이지 않은 공간에 존재하여 실행하지 못하는  현상이다.
- 50MB의 두 여유 메모리가 존재하고 총 100MB의 여유 메모리가 존재한다.
- 그러나, 연속적이지 않은 공간에 존재하여 80MB인 processC를 실행할 수 없다.

`메모리압축`(compaction)으로 해결할 수 있다.
프로세스가 사용중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합치는 것이다.

### `내부단편화`
필요이상의 메모리를 할당받아, 사용하지 않는 메모리 공간이 발생하는 현상이다.
- 100MB의 공간에 processC를 할당했다.
- 20MB의 여유 메모리가 존재하지만 processC에게 할당되어 사용할 수 없다.

## 2.2 가변 분할 방식
할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식이다.  
메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾는다.  

### 메모리 할당 알고리즘
### `최초적합` (first-fit)
가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 츠로세스를 로드하는 방식이다.

### `최적적합` (best-fit)
할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식이다.  
가용 메모리 공간을 모두 탐색해야 한다.

### `최악적합` (worst-fit)
할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식이다.  
가용 메모리 공간을 모두 탐색해야 한다. 


# 4. 비연속 메모리 할당
프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법이다.
## 4.1 Paging(페이징)
하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는) 페이지라 불리는 고정 크기의 블록으로 분리된다. 

- 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지와 프레임으로 나눈다.  
- 페이지와 프레임 크기는 동일하다.  
- 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑한다.
- 페이지와 프레임을 매핑하는 데는 페이지 테이블을 사용한다.  
- 페이지 테이블은 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장한다.  
- 페이지 테이블은 각 프로세스의 PCB에 저장된다.


페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 연속으로 할당할 필요가 없고 물리 메모리의 남는 프레임이 적절히 배치됨으로 외부 단편화 문제를 해결할 수 있다. 

하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다고 볼 수 있다. 

**`단점`**  
- 프로세스 크기가 페이지 수로 나누어 떨어지는지는 보장하지 않는다.  
- 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있어서 내부 단편화 문제가 발생할 수 있다.  
- 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요하다.  

예를들어 페이지 크기가 1,024B이고 프로세스 A가 3,172B의 메모리를 요구한다면  
3개의 페이지 프레임하고도 100B가 남기때문에 총 4개의 페이지 프레임이 필요한 것이다.  
결론적으로 4번째 페이지 프레임에는 924B의 여유 공간이 남게 되는 내부 단편화 문제가 발생한다.  

## 4.2 Segmentation(세그먼테이션)
페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할해 메모리를 할당한다.  
논리적 단위: 파일 내 함수 단위, 프로세스의 스택, 힙

세그먼테이션 테이블을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑한다.  
세그먼트 번호를 인덱스로 사용하며, 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit을 저장한다.

`장점`
- 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉼다.

`단점`
- 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부단편화 문제가 발생할 수 있다.
- 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있다.


## 참고
[[운영체제] 가상 메모리](https://velog.io/@redgem92/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)  
[내부 단편화, 외부 단편화](https://hojunking.tistory.com/109)  
[OS/메모리 관리 전략](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/main/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)