# 1. 프로세스와 스레드
## 1.1 `프로세스`
프로그램이 메모리에 올라가서 실행중인 상태를 “프로세스”라고 말한다.
<p align="center"><img width="500" alt="메모리구조" src="https://github.com/fbgjung/study-notes/assets/104186871/71c29f87-7284-4958-9bb9-fbb14b41efa2">  

OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다.  
프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당받으며, 다른 프로세스의 메모리 영역에 접근할 수 없다.  

## 1.2 프로세스의 메모리 영역 구조
- `code` : 실행할 코드가 기계어로 컴파일되어 저장되는 영역으로, 텍스트 영역이라고도 한다.
- `data` : 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역이다. BBS(Block Stated Symbol) 영역과 데이터 영역으로 다시 나눌 수 있다.  
    - BBS 영역: 초기화하지 않은 변수를 저장한다.
    - 데이터 영역: 초기화한 변수를 저장한다.
- `heap`: 사용자에 의해 동적 메모리 할당이 일어나는 영역이다. 낮은 주소 값에서 높은 주소 값으로 메모리가 할당되며, 영역 크기는 런타임 때 결정된다.
- `stack` : 지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역이다. 높은 주소 값에서 낮은 주소 값으로 메모리가 할당되며, 영역 크기는 컴파일 때 결정된다.

메모리 영역을 공유하기 때문에 서로위 영역을 침범하는 문제가 생길 수 있다.  
스택 오버플로: 스택 영역이 힙 영역을 침범하는 경우  
힙 오버플로: 힙 영역이 스택 영역을 침범하는 경우  

## 1.3 `스레드`
<p align="center"><img width="500" height ="300" alt="스레드" src="https://github.com/fbgjung/study-notes/assets/104186871/583fec12-ebb8-4e3f-97f3-a4a6e663153c">  </p>

- 프로세스는 한 개 이상의 스레드를 갖는다.  
- 프로세스에서 실제로 실행되는 흐름의 단위를 의미한다.  
- 스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 지역 변수를 저장하는 스택 영역을 할당받는다. 
- 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유한다.


# 2. PCB(Process Control Block, 프로세스 제어 블록)
OS는 프로세스를 제어하기 위해 프로세스 정보를 저장한다.  

프로그램이 프로세스가 된다는 것은 운영체제로부터 프로세스 제어 블록을 얻는다는 뜻  
프로세스가 종료된다는 것은 해당 프로세스 제어 블록이 폐기된다는 뜻  
프로세스: 프로그램 + 프로세스 제어 블록  

|PCB|
|:-:|
|포인터|
|프로세스 상태|
|PID(프로세스ID)|
|PC(프로그램카운터)|
|레지스터|
|메모리 제한|
|열린 파일 목록|
|CPU스케줄링 정보|

# 3. 프로세스의 생성
새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성한다.  
fork() 함수에는 함수를 호출한 프로세스를 복사하는 기능이 있다.  
기존 프로세스를 부모 프로세스, 복사된 프로세스를 자식 프로세스라고 한다.  
부모 프로세스에서 fork() 함수를 호출하면 부모 프로세스는 자식 프로세스의 PID 값을, 자식 프로세스는 0을 반환한다.  

fork() 함수의 반환값이 2개.. 시스템 콜을 호출하는 코드를 보도 이해해보자.
```C
#include<stdio.h>
#include<unistd.h>

int main() {
    printf("start!\n");
    int forkRet = fork();

    if(fortRet == 0) {
        printf("child process %d\n", getpid());
    } else {
        printf("forkRet: %d parent process: %d\n", forkRet, getpid());
    }
    return 0;
}
```
```text
start!
forkRet: 136 parent process: 135
child process 136
```

> 부모 프로세스는 다음과 같은 경우에 자식 프로세스를 종료시킬 수 있다.  
> - 자식 프로세스가 할당된 자원을 초과해 사용할 때
> - 자식 프로세스에 할당된 작업이 없을 때

## 운영체제가 프로세스를 종료하는 경우
- 프로세스가 운영체제의 종료 서비스(exit())를 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우

# 4. 프로세스 상태도
모든 프로세스는 `CPU`에 의해 생성되고 소멸하는 과정을 거친다.  
<p align="center"><img width="500" alt="프로세스상태도" src="https://github.com/fbgjung/study-notes/assets/104186871/e401b1b6-df96-4fdf-bd93-5324e999713e">

- `생성(new)`: 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
    - 프로세스가 PCB를 가지고 있지만 OS로부터 승인 받기 전
    - 메모리에 프로그램 적재를 요청한 상태이다. 
- `준비(ready)`: OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다리고 있는 상태
    - 준비 상태에 있는 프로세스는 CPU 스케줄러에 의해 CPU가 할당된다.
    - 대부분의 프로세스는 준비상태에 있다.
- `실행(running)`: 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태이다.
    - 실행상태에 있는 프로세스의 수는 CPU의 개수만큼이다.
    - 실행상태에 있는 프로세스도 CPU를 무한정 쓸 수 있는 것이 아니라 부여된 시간만큼만 사용할 수 있다.
    - CPU 스케줄러는 부여된 시간을 초과하면 할당된 CPU를 강제로 빼았는다 -> 프로세스는 다시 준비상태로 돌아간다.
- `대기(waiting)`: 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 완료될 때까지 기다리는 상태
    - 그 사이에 다른 프로세스에 CPU 할당
- `종료(terminated)`: 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거하며 실행을 종료한 상태이다.

## 4.1 프로세스 상태 변화
1. 생성 -> 준비 : 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 자료구조인 `준비 큐`에 추가됨
2. 준비 -> 실행 : 준비 큐에 있는 프로세스 중 `우선순위`가 높은 프로세스가 `디스패치`되어 실행됨
3. 실행 -> 준비 : CPU 독점을 방지하기 위해 타임아웃되어 준비 상태로 변경됨
4. 실행 -> 대기 : 입출력 또는 이벤트 때문에 대기 상태로 변경됨
5. 대기 -> 준비 : 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
6. 실행 -> 종료 : 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

## `디스패치`
프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것을 의미한다.

# 5. 멀티 프로세스와 멀티 스레드
## 5.1 `동시성` (concurrency)
하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식이다.  
CPU는 한 번에 하나의 작업만 처리할 수 있어서 여러 작업을 조금씩 돌아가면서 처리한다.  

하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것을 `콘텍스트 스위칭`이라고 한다.


## 5.2 `병렬성` (parallelism)
CPU가 여러 개(멀티 코어)있어서 각 CPU에서 각 작업을 동시에 처리하는 방식이다.  
물리적인 시간 관점에서 동시에 여러 작업이 처리된다.  

## 5.3 멀티 프로세스
<p align="center">
<img width="500" alt="멀티프로세스" src="https://github.com/fbgjung/study-notes/assets/104186871/d0103c92-e084-4f61-8f8c-98700cbe6261"></p>

응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미한다.
멀티 프로세스 환경에서는 한 프로세스가 다른 프로세스에 영향을 주지 않아 안정적이다.

### 멀티 프로세스 단점
1. 시간과 메모리 공간을 많이 차지한다.  
    CPU는 하나의 작업만 처리할 수 있다. 여러 프로세스를 처리하려면 CPU에서 처리 중인 프로세스를 교체하는 `콘텍스트 스위칭` 작업이 이루어져야 한다.  
    이때 CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하면서 시간과 메모리가 필요한데, 이를 `오버헤드`라고 한다.
2. 프로세스는 독립적인 메모리를 할당받는다.  
    프로세스 간에 공유할 자원이 있다면 `IPC`(Inter Process Communication)를 통해 프로세스 간에 자원을 공유해야 한다. 그래서 공유할 메모리를 직접 참조하는 것보다 비효율적이다.

## 5.4 멀티 스레드
스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미한다.
- 멀티 스레드는 스레드 간에 <U>힙, 데이터, 코드 영역을 공유한다.</U> 
- 콘텍스트 스위칭할 때 오버헤드가 적게 발생한다.

    - 스택을 제외한 힙, 데이터, 코드 영역을 공유하므로 레지스터에 저장하고 로드해야 하는 데이터가 상대적으로 적기 때문이다.
- IPC를 사용하지 않아도 되어 멀티 프로세스의 단점을 보완할 수 있다.
- 독립적인 메모리 공간을 갖는 프로세스를 여러 개 생성하는 것보다 스레드를 여러 개 생성하는 것이 자원을 효율적으로 사용할 수 있다.
- 스레드 간 자원 공유가 프로세스 간 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축된다. 
- <U>스택 영역을 다른 스레드와 함께 사용</U>하므로 공유 자원에 대한 동기화가 필수다.
- 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향을 미칠 수 있다.

# ⭐️6. 콘텍스트 스위칭
`멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것`

CPU는 하나의 프로세스만 처리할 수 있으므로 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해 인터럽트가 발생하면서 콘텍스트 스위칭이 이뤄진다.  

## 6.1 인터럽트
CPU에서 프로세스를 처리하다가 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것이다.  
`콘텍스트`: CPU가 처리하는 프로세스의 정보를 의미한다.  
- 입출력이 발생할 때
- CPU 사용 시간이 만료됐을 때
- 자식 프로세스를 생성할 때

## 6.2 콘텍스트 스위칭 과정
> 콘텍스트 스위칭을 하려면, 현재 실행중인 프로세스의 정보를 저장하는 것이 필요한데, 이때 사용하는 자료구조가 PCB(프로세스 제어 블록)이다. PCB에는 현재 CPU에 의해 실행중인 프로세스에 관하여 CPU 레지스터가 갖고 있는 정보들을 저장한다. 이렇게 PCB에 프로세스 정보를 저장해두고, 다른 프로세스의 PCB에 있는 정보를 CPU의 레지스터에 로드하여 다른 프로세스를 실행하게 된다. 

1. CPU가 P1을 처리하던 중
2. 운영체제에 의해 인터럽트가 발생한다.
3. P1은 유휴상태(idle)로 변하고 스케줄러는 레지스터에 있는 처리 중인 작업 정보를 P1의 PCB에 저장한다.
4. P2의 PCB에 있는 정보를 가져와 레지스터에 로드한다.
5. CPU는 P2를 처리하기 시작한다.  

이때 P1의 정보를 P1의 PCB에 저장하고, P2의 PCB에 저장된 정보를 레지스터에 로드하는 동안 CPU는 아무 일도 못 하게 된다.  
어떤 처리를 하는 데 간접적인 처리 시간과 메모리가 소요될 경우에 `오버헤드가 발생한다`고 한다.  

CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유는 PCB에 `프로그램 카운터`와 `스택 포인터 값`이 저장되어 있기 때문이다.  
- `프로그램 카운터`: 프로세스가 이어서 처리해야 하는 명령어의 주소 값
- `스택 포인터`: 스택 영역에서 데이터가 채워진 가장 높은 주소 값

## 6.3 콘텍스트 스위칭이 일어나는 조건
1. 현재 프로세스에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때 까지 waiting 상태로 전이될 경우
2. RR 스케줄링 등의 알고리즘에서 현재 프로세스가 사용할 수 있는 시간 자원을 모두 사용했을 때 해당 프로세스를 중지하고 다른 프로세스를 실행시켜주는 경우

# 7 프로세스 동기화
## 7.1 경쟁상태
여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있은데, 이때 자원에 접근하는 순서에 따라 결과 값이 달라질 수 있다.  
프로세스 동기화가 이루어져야 한다.

## 7.2. 임계영역
공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역이다.  
냉장고에 우유 유무를 판단하고 우유를 추가하는 부분이 임계 영역에 해당한다.  
임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면,  
여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 프로세스 동기화를 해야 한다.

### 임계영역에 여러 접근이 동시에 발생하는 것을 방지하기 위한 조건
1. `상호배제 기법`(mutual exclusive) : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없다. (뮤텍스와 세마포어)
2. `진행`(progress) : 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.
3. `한정된 대기`(bounded waiting) : 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않는다.

## 7.3 뮤텍스
락을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법이다.  
[1] 식당에는 화장실 한 칸과 화장실 문을 열 수 있는 열쇠 한 개가 있다.  
[2] A가 열쇠를 가지고 화장실에 간다.  
[3] 화장실에 가려던 B는 열쇠가 없어서 기다린다.  
[4] A가 화장실에서 나와 열쇠를 반납하면, 기다리던 B가 열쇠를 가지고 화장실에 간다. 

여기서 화장실은 공유 자원을 포함한 임계 영역을, 열쇠는 락을, A와 B는 공유 자원에 접근하려는 프로세스를 의미한다.  
임계 영역에 접근한 프로세스가 임계 영역에 락을 건다고 해서 `락킹 매커니즘`이라고도 한다.

임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 락이 풀렸는지 반복문을 돌면서 확인한다. 이를 `바쁜 대기`의 한 종류인 `스핀락`이라고 한다.  

프로세스가 대기 상태가 되지 않고 반복문을 돌면서 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있다.

## 7.4 세마포어
공유자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법이다.  
임계 영역에 접근할 수 있는 키 n개를 지정하고 이 중 하나를 가진 프로세스만이 임계 영역에 접근하게 하는 방식이다.  
공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 `시그널링 메커니즘`이라고도 한다.

## 7.5 동기 vs 비동기 / 블로킹 vs 넌블로킹
- 동기(synchronization) : 여러 작업을 처리할 때 작업 순서를 보장함
- 비동기(asynchronization) : 여러 작업을 처리할 때 작업 순서를 보장하지 않음
- 블로킹(blocking) : 작업을 수행할 때 대기할 수 있다는 것을 의미하며 작업 순서를 보장하지 않음
- 넌블로킹(non-blocking) : 작업을 시작하면 대기 없이 수행한다는 것을 의미함

# 8. 교착 상태
상호배제 기법(뮤텍스와 세마포어) 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태이다.  
## 8.1 4가지 필요 충분 조건
- `상호배제`: 하나의 공유 자원에 하나의 프로세스만 접근할 수 있다. 
- `점유와 대기`: 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.
- `비선점`: 다른 프로세스에 할당된 자원을 뺏을 수 없다.
- `환형 대기`: 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

교착 상태를 막으려면 4가지 필요 충분 조건 중에서 한 가지를 제거하면 된다.  

# 9. 스레드 안전
멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미한다.  
### 스레드 안전하기 위해 지켜야할 조건
- 상호배제: 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호배제 기법을 사용해 접근을 통제해야 한다.
- 원자 연산: 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 한다. 
    - "연산했다"와 "연산 안 했다" 두 가지만 존재하는 연산이다.
- 재진입성: 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 한다.
- 스레드 지역 저장소: 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄여야 한다.

# 10. IPC(Inter Process Communication)
`프로세스 간에 자원을 공유하는 방식 (통신)`   
프로세스는 고유한 메모리 영역을 갖기 때문에 프로세스 간 자원을 공유해야 할 때 IPC 해야 한다.  

## 10.1 공유 메모리
프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식이다.  
여러 프로세스에서 접근할 수 있어서 `동기화 문제`가 발생할 수 있다.  

## 10.2 소켓
네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있다.  
클라이언트와 서버 구조로 자원을 주고받는다.  

## 10.3 세마포어
접근하는 프로세스를 제어해 공유 자원을 관리한다.

## 10.4 파이프
`FIFO` 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식이다.  
파이프는 `단방향 통신`만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 있다.  
양방향 통신을 하려면 읽기 파이프와 쓰기 파이프를 각각 생성해야 한다.  

## 10.5 메시지 큐
`FIFO` 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식이다.  

# 11. 좀비 프로세스와 고아 프로세스
## 11.1 좀비 프로세스
자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스를 말한다.  
자식 프로세스가 종료될 때 부모 프로세스에 `SIGCHLD`라는 시그널을 보내면 부모 프로세스에서 wait() 함수(시스템 콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원을 회수한다.  
이때 자원 회수에 실패하면 좀비 프로세스가 생기게 된다. 좀비 프로세스가 쌓이면 자원이 낭비될 수 있다.

## 11.2 고아 프로세스
부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스를 말한다.  
자식 프로세스의 부모 PID를 init 프로세스의 PID인 1로 바꿔준다.  
이렇게 하면 고아 프로세스의 부모 프로세스는 init 프로세스가 된다.  
이후에 고아 프로세스가 작업을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수해 좀비 프로세스가 되는 것을 방지할 수 있다.  

## 참고
[[운영체제] 프로세스와 스레드](https://velog.io/@aeong98/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C)